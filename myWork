%scaner_name Lexer
%codes_type lexem_code

%codes 
Id
%ident_name 
Id
%token_fields
"unsigned __int128 int_val; __float128 float_val;"
%class_members
"unsigned __int128 int_part; __float128 frac_part; ssize_t power; ssize_t sign; bool is_float; unsigned num_of_digits_in_frac_part;"
%codes
String, If, Float,
Else, Var, Int,
Bool, Char, Void,
Array, True, False,
Proto, Func, Const,
Elif, Endif, For,
In, While, Repeat,
Until, Exit, Continue,
Return, Read, Print,
Kw_string,Kw_float,
Kw_int,Kw_char, Kw_void,
Kw_bool,

Equal, Plus, Minus,
Mul, Div, Mod,
LT, GT, LEQ,
GEQ, Nequal, FDiv,
Lor, LNor, LNot,
LAnd, LNand, LXor,
LNXor, BXor, BNXor,
Bor, BNor, BAnd,
BNAnd, LShift, RShift,
BNot, Pow, FPow,
Assign, Open_body_func, Close_body_func,
Open_list_of_names, Close_list_of_names, Dim_size,
cond_op, Semicolon, Comma,
after_label, Open_list_of_expr, Close_list_of_expr,
Colon, APlus, AMinus, 
AMul, ADiv, AFDiv, 
APow, AFPow, AMod,
ABAnd, ABNAnd, ALShift,
ARShift, ABor, ABNor,
ABXor, ABNXor, ALor,
ALNor, ALXor, ALNXor,
ALAnd, ALNAnd 


%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}

%keywords
"если" : If, "иначе" : Else, "цел" : Kw_int, "перем": Var, "вещ" : Kw_float,"лог": Kw_bool,
"симв" : Kw_char, "строка" :Kw_string,
"ничто" : Kw_void, "массив" : Array, "истина": True, "ложь": False,"прото": Proto,
"функ": Func, "конст": Const, "то" : To, "инес": Elif, "всё": Endif,"для": For,
"из": In,"пока": While, "повторяй": Repeat, "покуда": Until, "выйди": Exit,
"продолжи": Continue, "возврат": Return, "ввод": Read, "вывод":Print

%delimiters
"=" : Equal, "+" : Plus, "-" : Minus, "*" : Mul, "/" : Div, "%" : Mod,
"<": LT, ">":GT, "<=": LEQ, ">=":GEQ, "!=":Nequal,"/.": FDiv, "||": Lor,
"!||": LNor, "!":LNot, "&&": LAnd, "!&&": LNAnd, "^^": LXor,
"!^^": LNXor,"^":BXor,"~^":BNXor,"|":Bor, "~|":BNor,
"&":BAnd, "~&":BNAnd, "<<":LShift,">>":RShift,"~":BNot, "**":Pow, "**.":FPow,":=":Assign, 
"{":Open_body_func,"}":Close_body_func, "(":Open_list_of_names, ")":Close_list_of_names,"#":Dim_size, "?":cond_op,";":Semicolon, ",":Comma, 
"::":after_label,"[":Open_list_of_expr,"]":Close_list_of_expr,":":Colon, "+:=" : APlus, "-:=" : AMinus, "*:=" : AMul, "/:=" : ADiv, "/.:=" : AFDiv,
"**:=" : APow, "**.:=" : AFPow, "%:=" : AMod,
"&:=" : ABAnd, "~&:=" : ABNAnd, "<<:=" : ALShift, ">>:=" : ARShift, "|:=" : ABor, "~|:=" : ABNor, "^:=" : ABXor, 
"~^:=" : ABNXor, "||:=" : ALor, "!||:=" : ALNor, "^^:=" : ALXor, "!^^:=" : ALNXor, "&&:=" : ALAnd, "!&&:=" ALNAnd


%impl_additions 
"size_t digit2int(char32_t){ 
         if ((digits>= '0') && (digits <= '9')) 
            return digits - '0'; 
         else
            return -1;
 }"

%strings "buffer.clean();":"token.code=(buffer.length()==1)?Char:String;"
{"([:ndq:]$write|""$write)*"}   


%numbers  "int_part= 0;frac_part=1;is_float=0;sign=0;power=0;num_of_digits_in_frac_part=0; token.code = Number;" : "token.int_val = int_part;"

  %action addDecdigit "frac_part=frac_part*10+digit2int(ch)"
  %action addDecDigit "int_part = int_part * 10 + digitToInt(ch);" 
  %action addOctDigit "int_part = (int_part<< 3) + digitToInt(ch);
  %action addBinDigit "int_part = (int_part<< 1) + digitToInt(ch);"
  %action addHexDigit "int_part = (int_part << 4) + digitToInt(ch);"


{[:digits:](?[digits:])*$addDecDigit+ | 0(o|O)[:odigits:](?[odigits:])*$addOctDigit+ |
0(b|B)[:bdigits:](?[bdigits:])*$addBinDigit+ | 0(x|X)[:xdigits:](?[xdigits:])*$addHexDigit+|[:digits:](?[digits:])*$addDecdigit+(.$addDecdigit+[:digits:](?[digits:])*((E|e)(+|-)?[:digits:](?[digits:])*)?)}


 
